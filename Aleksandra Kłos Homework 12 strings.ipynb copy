{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "84dd1838",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 1. [Character permutations] Write a Python program that takes a five-letter word and produces\n",
    "# every possible two-letter string, based on the word’s letters. For example, the two-letter\n",
    "# words produced from the word “bathe” include “ba”, “bt”, “bh”, “be”, “ab“, “at”, “ah”, “ae”,\n",
    "# and so on.\n",
    "# a. Your function should solely rely on (nested) loops\n",
    "# b. Take a look at the itertools module\n",
    "# (https://docs.python.org/3/library/itertools.html) and find a function that realizes\n",
    "# the required functionality. Compare its output to that of your program.\n",
    "# c. Which difficulty would you run into when trying to extend your program towards\n",
    "# permutations of arbitrary length?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0d4d6fb4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def mypermutations(data):\n",
    "    m=[]\n",
    "    for i in range(len(data)):\n",
    "        for j in range(len(data)):\n",
    "            if i!=j:\n",
    "                m.append(data[i]+data[j])\n",
    "    return m\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "ea9eaddf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['ba',\n",
       " 'bt',\n",
       " 'bh',\n",
       " 'be',\n",
       " 'ab',\n",
       " 'at',\n",
       " 'ah',\n",
       " 'ae',\n",
       " 'tb',\n",
       " 'ta',\n",
       " 'th',\n",
       " 'te',\n",
       " 'hb',\n",
       " 'ha',\n",
       " 'ht',\n",
       " 'he',\n",
       " 'eb',\n",
       " 'ea',\n",
       " 'et',\n",
       " 'eh']"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "mypermutations('bathe')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "e48497da",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['ba', 'bt', 'bh', 'be', 'ab', 'at', 'ah', 'ae', 'tb', 'ta', 'th', 'te', 'hb', 'ha', 'ht', 'he', 'eb', 'ea', 'et', 'eh'] 20\n"
     ]
    }
   ],
   "source": [
    "from itertools import permutations\n",
    "perm=[''.join(p) for p in permutations('bathe',2)]\n",
    "print(perm, len(perm))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "2847379f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#2. [Regular expressions: munging dates] Dates are stored and displayed in several common\n",
    "# formats. Three common formats are\n",
    "# 042555\n",
    "# 04/25/1955\n",
    "# April 25, 1955\n",
    "# Use regular expressions to search a string containing dates, find substrings that match these\n",
    "# formats and munge them into the other formats. The original string should have one date in\n",
    "# each format, so there will be a total of six transformations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "7338e37f",
   "metadata": {},
   "outputs": [],
   "source": [
    "dates= [ '042555', '12/25/1957', 'April 25, 1959']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "2bfb68b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "pattern_1=\"^[0-9]{1,2}[0-9]{1,2}[0-9]{4}$\"\n",
    "pattern_2=\"(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])/[0-9]{4}$\"\n",
    "pattern_3=\"(January|February|March|April|May|June|July|August|September|October|November|December)\\s\\d{2},\\s\\d{4}$\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "02558a3f",
   "metadata": {},
   "outputs": [],
   "source": [
    "months={'Januray':'01',\n",
    "        'February':'02',\n",
    "        'March':'03',\n",
    "        'April':'04',\n",
    "        'May':'05',\n",
    "        'June':'06',\n",
    "        'July':'07',\n",
    "        'August':'08',\n",
    "        'September':'09',\n",
    "        'October':'10',\n",
    "        'November':'11',\n",
    "        'December':'12'\n",
    "       }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "89c4c530",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Transformations of 042555 : 25/04/2055, April 25, 2055\n",
      "Transformations of 12/25/1957 : 251257, December 25, 1957\n",
      "Transformations of April 25, 1959 : 042559, 25/04/1959 \n"
     ]
    }
   ],
   "source": [
    "import re \n",
    "for y in dates:\n",
    "    if bool(re.match(pattern_1, y))==True:\n",
    "        lst=[y[2:4], y[:2],'20'+y[4:]]\n",
    "        lst2=[list(months.keys())[int(y[:2].strip('0'))-1], y[2:4]+',', '20'+ y[-2:]]\n",
    "        print(f\"Transformations of {y} : {r'/'.join(lst)}, {r' '.join(lst2)}\" )\n",
    "    elif bool(re.match(pattern_2, y))==True:\n",
    "        lst1=[y[3:5],y[:2], y[-2:]]\n",
    "        lst3=[list(months.keys())[int(y[:2].strip('0'))-1], y[3:5]+',', y[-4:] ]\n",
    "        print(f'Transformations of {y} : {\"\".join(lst1)}, {\" \".join(lst3)}' )\n",
    "    elif bool(re.match(pattern_3, y))==True:\n",
    "        lst4=[months[y.split()[0]],y.split(' ')[1].strip(','), y.split(' ')[2][-2:] ]\n",
    "        lst5=[y.split(' ')[1].strip(','), months[y.split()[0]], '19'+y.split(' ')[2][-2:] ]\n",
    "        print(f\"Transformations of {y} : {''.join(lst4)}, {'/'.join(lst5)} \")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1a9e9e44",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
